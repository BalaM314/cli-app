/*
Copyright Â© <BalaM314>, 2024.
This file is part of cli-app.
cli-app is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
cli-app is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
You should have received a copy of the GNU Lesser General Public License along with cli-app. If not, see <https://www.gnu.org/licenses/>.

Contains unit tests for Script.
*/

import path from "node:path";
import { Script } from "../../build/Script.js";
import { ApplicationError } from "../../build/classes.js";
import { applicationError, testOptions, types } from "./test-utils.js";

describe("Script", () => {
	const fakePathToApp = path.join(process.cwd(), "test.js");
	it("should run a script without crashing", async () => {
		const script = new Script("test-app", "Autogenerated test app", (opts, app) => {});
		spyOn(script.defaultCommand, "handler").and.callThrough();
		await script.run(["node", fakePathToApp], testOptions);
		expect(script.defaultCommand.handler).toHaveBeenCalled();
	});

	it("should accept named arguments", async () => {
		const script = new Script("test-app", "Autogenerated test app", (opts, app) => {
			expect(opts.namedArgs["namedarg1"]).toEqual("namedvalue1");
			expect(opts.namedArgs["namedarg2"]).toEqual(undefined);
			types<typeof opts.namedArgs.namedarg1, string>().areEqual();
			types<typeof opts.namedArgs.namedarg2, string | null | undefined>().areEqual();
		}, {
			namedArgs: {
				namedarg1: {
					description: "test arg",
				},
				namedarg2: {
					description: "test arg",
					optional: true,
				},
			}
		});

		spyOn(script.defaultCommand, "handler").and.callThrough();
		await script.run(["node", fakePathToApp, `--namedarg1`, `namedvalue1`], testOptions);
		expect(script.defaultCommand.handler).toHaveBeenCalled();
	});

	it("should accept positional arguments", async () => {
		const script = new Script("test-app", "Autogenerated test app", (opts, app) => {
			expect(opts.positionalArgs[0]).toEqual("namedvalue1");
			expect(opts.positionalArgs[1]).toEqual(undefined);
		}, {
			positionalArgs: [
				{
					name: "arg1",
					description: "test arg",
				},
				{
					name: "arg2",
					description: "test arg",
					optional: true
				},
			]
		});
		spyOn(script.defaultCommand, "handler").and.callThrough();
		await script.run(["node", fakePathToApp, `namedvalue1`], testOptions);
		expect(script.defaultCommand.handler).toHaveBeenCalled();
	});

	it("should fail if a required named argument is not passed", async () => {
		const script = new Script("test-app", "Autogenerated test app", (opts, app) => {
			
		}, {
			namedArgs: {
				namedarg1: {
					description: "test arg",
				},
			}
		});

		await expectAsync(script.run(["node", fakePathToApp], testOptions))
			.toBeRejectedWith(applicationError("required named arg"));
		
	});

	it("should fail if a required positional argument is not passed", async () => {
		const script = new Script("test-app", "Autogenerated test app", (opts, app) => {
			
		}, {
			positionalArgs: [
				{
					name: "positionalArg1",
					description: "test arg"
				},
			]
		});

		await expectAsync(script.run(["node", fakePathToApp], testOptions))
			.toBeRejectedWith(applicationError("required positional arg"));
	});

	it("should fill in default values for named arguments", async () => {
		const script = new Script("test-app", "Autogenerated test app", (opts, app) => {
			expect(opts.namedArgs["optional1"]).toEqual("defaultValue1");
			expect(opts.namedArgs["optional2"]).toEqual("defaultValue2");
			types<typeof opts.namedArgs.optional1, string>().areEqual();
			types<typeof opts.namedArgs.optional2, string>().areEqual();
		}, {
			namedArgs: {
				optional1: {
					description: "test arg",
					default: "defaultValue1"
				},
				optional2: {
					description: "test arg",
					default: "defaultValue2"
				},
			}
		});

		spyOn(script.defaultCommand, "handler").and.callThrough();
		await script.run(["node", fakePathToApp, `--optional2`], testOptions);
		expect(script.defaultCommand.handler).toHaveBeenCalled();
	});

	it("should fill in default values for positional arguments", async () => {
		const script = new Script("test-app", "Autogenerated test app", (opts, app) => {
			expect(opts.positionalArgs[0]).toEqual("value1");
			expect(opts.positionalArgs[1]).toEqual("defaultValue2");
		}, {
			positionalArgs: [
				{
					name: "arg1",
					description: "test arg",
					default: "defaultValue1"
				},
				{
					name: "arg2",
					description: "test arg",
					default: "defaultValue2"
				},
			]
		});

		spyOn(script.defaultCommand, "handler").and.callThrough();
		await script.run(["node", fakePathToApp, `value1`], testOptions);
		expect(script.defaultCommand.handler).toHaveBeenCalled();
	});

	it("should not allow required positional arguments to follow optional ones", () => {
		expect(() => {
			const script = new Script("test-app", "Autogenerated test app", (opts, app) => {
				expect(opts.positionalArgs[0]).toEqual("value1");
				expect(opts.positionalArgs[1]).toEqual("defaultValue2");
			}, {
				positionalArgs: [
					{
						name: "arg1",
						description: "test arg",
						default: "defaultValue1"
					},
					{
						name: "arg2",
						description: "test arg",
					},
				]
			});
		}).toThrowMatching((err:Error) => !(err instanceof ApplicationError) && err.message.includes("cannot follow optional ones"));
	});

	it("should accept aliases for named arguments", async () => {
		const script = new Script("test-app", "Autogenerated test app", (opts, app) => {
			expect(opts.namedArgs["namedarg1"]).toEqual("namedvalue1");
			expect(opts.namedArgs["namedarg2"]).toEqual("namedvalue2");
		}, {
			namedArgs: {
				namedarg1: {
					description: "test arg",
					aliases: ["alias1"]
				},
				namedarg2: {
					description: "test arg"
				},
			},
			aliases: {
				alias2: "namedarg2"
			}
		});

		spyOn(script.defaultCommand, "handler").and.callThrough();
		await script.run(["node", fakePathToApp, `--alias1`, `namedvalue1`, `--alias2`, `namedvalue2`], testOptions);
		expect(script.defaultCommand.handler).toHaveBeenCalled();
	});

	it("should correctly handle parsing positional args following valueless named args", async () => {
		const script = new Script("test-app", "Autogenerated test app", (opts, app) => {
			types<typeof opts.namedArgs.namedarg1, boolean>().areEqual();
			expect(opts.namedArgs["namedarg1"]).toEqual(true);
			expect(opts.namedArgs["namedarg2"]).toEqual("namedvalue2");
			expect(opts.positionalArgs).toEqual(["posarg1"]);
		}, {
			namedArgs: {
				namedarg1: {
					description: "test arg",
					valueless: true,
					aliases: ["alias1"]
				},
				namedarg2: {
					description: "test arg"
				},
			},
			aliases: {
				alias2: "namedarg2"
			}
		});

		spyOn(script.defaultCommand, "handler").and.callThrough();
		await script.run(["node", fakePathToApp, `--alias1`, `posarg1`, `--namedarg2`, `namedvalue2`], testOptions);
		expect(script.defaultCommand.handler).toHaveBeenCalled();
	});
	
});