/* eslint-disable @typescript-eslint/no-empty-function */
/*
Copyright Â© <BalaM314>, 2024.
This file is part of cli-app.
cli-app is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
cli-app is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
You should have received a copy of the GNU Lesser General Public License along with cli-app. If not, see <https://www.gnu.org/licenses/>.

Contains unit tests for Application.
*/

import path from "node:path";
import type fs from "node:fs";
import { Application, arg } from "../../build/Application.js";
import { applicationError, delay, fakePathToApp, runApp, types } from "./test-utils.js";

describe("Application", () => {

	it("should run an application without crashing", async () => {
		const app = new Application("test-app", "Autogenerated test app");
		app.command("cmd1", "test command").args({}).impl(() => {});
		spyOn(app.commands["cmd1"]!, "handler").and.callThrough();
		await runApp(app, [`cmd1`]);
		expect(app.commands["cmd1"]!.handler).toHaveBeenCalled();
	});

	it("should accept named arguments", async () => {
		const app = new Application("test-app", "Autogenerated test app");
		app.command("cmd1").description("test command").args({
			namedArgs: {
				namedarg1: arg()
			}
		}).impl((opts, app) => {
			types<string, typeof opts.namedArgs["namedarg1"]>().areEqual();
			expect(opts.namedArgs.namedarg1).toEqual("namedvalue1");
		});

		spyOn(app.commands["cmd1"]!, "handler").and.callThrough();
		await runApp(app, [`cmd1`, `--namedarg1`, `namedvalue1`]);
		expect(app.commands["cmd1"]!.handler).toHaveBeenCalled();
	});

	it("should handle named arguments being optional", async () => {
		const app = new Application("test-app", "Autogenerated test app");
		app.command("cmd1").description("test command").args({
			namedArgs: {
				passed_without_value: arg().optional(),
				not_passed: arg().optional(),
			}
		}).impl((opts, app) => {
			types<typeof opts.namedArgs["passed_without_value"], string | null | undefined>().areEqual();
			types<typeof opts.namedArgs["not_passed"], string | null | undefined>().areEqual();
			expect(opts.namedArgs.passed_without_value).toEqual(null);
			expect(opts.namedArgs.not_passed).toEqual(undefined);
			expect("not_passed" in opts.namedArgs).toEqual(true);
		});

		spyOn(app.commands["cmd1"]!, "handler").and.callThrough();
		await runApp(app, [`cmd1`, `--passed_without_value`]);
		expect(app.commands["cmd1"]!.handler).toHaveBeenCalled();
	});

	it("should accept valueless named arguments", async () => {
		const app = new Application("test-app", "Autogenerated test app");
		app.command("cmd1").description("test command").args({
			namedArgs: {
				namedarg1: arg().valueless(),
				namedarg2: arg().valueless(),
			}
		}).impl((opts, app) => {
			types<typeof opts.namedArgs.namedarg1, boolean>().areEqual();
			types<typeof opts.namedArgs.namedarg2, boolean>().areEqual();
			expect(opts.namedArgs.namedarg1).toEqual(true);
			expect(opts.namedArgs.namedarg2).toEqual(false);
		});

		spyOn(app.commands["cmd1"]!, "handler").and.callThrough();
		await runApp(app, [`cmd1`, `--namedarg1`, `notnamedvalue1`]);
		expect(app.commands["cmd1"]!.handler).toHaveBeenCalled();
	});

	it("should accept required valueless named arguments", async () => {
		const app = new Application("test-app", "Autogenerated test app");
		app.command("cmd1").description("test command").args({
			namedArgs: {
				namedarg1: arg().valueless().required()
			}
		}).impl((opts, app) => {
			types<typeof opts.namedArgs.namedarg1, true>().areEqual();
			expect(opts.namedArgs.namedarg1).toEqual(true);
		});

		await expectAsync(runApp(app, [`cmd1`])).toBeRejectedWith(applicationError("required named arg"));
	});

	it("should accept positional arguments", async () => {
		const app = new Application("test-app", "Autogenerated test app");
		
		app.command("cmd1").description("test command").args({
			positionalArgs: [
				{
					name: "arg1",
					description: "test arg",
				},
				{
					name: "arg2",
					description: "test arg",
					optional: true
				},
			]
		}).impl((opts, app) => {
			expect(opts.positionalArgs[0]).toEqual("namedvalue1");
			expect(opts.positionalArgs[1]).toEqual(undefined);
			expect(opts.positionalArgs.length).toEqual(2);
		});
		spyOn(app.commands["cmd1"]!, "handler").and.callThrough();
		await runApp(app, [`cmd1`, `namedvalue1`]);
		expect(app.commands["cmd1"]!.handler).toHaveBeenCalled();
	});

	it("should fail if a required named argument is not passed", async () => {
		const app = new Application("test-app", "Autogenerated test app");
		app.command("cmd1").description("test command").args({
			namedArgs: {
				namedarg1: arg(),
			}
		}).impl((opts, app) => {
			types<typeof opts.namedArgs.namedarg1, string>().areEqual();
			fail(`Handler should not be called`);
		});

		await expectAsync(runApp(app, [`cmd1`]))
			.toBeRejectedWith(applicationError("required named arg"));
		
	});

	it("should fail if an unexpected named argument is passed", async () => {
		const app = new Application("test-app", "Autogenerated test app");
		app.command("cmd1").description("test command").args({
			namedArgs: {
				namedarg1: arg(),
			},
			unexpectedNamedArgCheck: "error",
		}).impl((opts, app) => {
			types<typeof opts.namedArgs.namedarg1, string>().areEqual();
			fail(`Handler should not be called`);
		});

		await expectAsync(runApp(app, ["cmd1", `-namedarg1`]))
			.toBeRejectedWith(applicationError("Unexpected argument"));
	});

	it("should warn if an unexpected named argument is passed", async () => {
		const app = new Application("test-app", "Autogenerated test app");
		app.command("cmd1").description("test command").args({
			namedArgs: {
				namedarg1: arg().optional(),
			},
			unexpectedNamedArgCheck: "warn",
		}).impl((opts, app) => {
			types<typeof opts.namedArgs.namedarg1, string | null | undefined>().areEqual();
		});

		spyOn(app.commands["cmd1"]!, "handler").and.callThrough();
		spyOn(console, "warn");
		await runApp(app, ["cmd1", `--namedarg111`, `--namedarg1`]);
		expect(console.warn).toHaveBeenCalled();
		expect(app.commands["cmd1"]!.handler).toHaveBeenCalled();
	});

	it("should ignore if an unexpected named argument is passed", async () => {
		const app = new Application("test-app", "Autogenerated test app");
		app.command("cmd1").description("test command").args({
			namedArgs: {
				namedarg1: arg().optional(),
			},
			unexpectedNamedArgCheck: "ignore",
		}).impl((opts, app) => {
			types<typeof opts.namedArgs.namedarg1, string | null | undefined>().areEqual();
		});

		spyOn(app.commands["cmd1"]!, "handler").and.callThrough();
		spyOn(console, "warn").and.callThrough();
		await runApp(app, ["cmd1", `--unexpected-named-arg`]);
		expect(console.warn).not.toHaveBeenCalled();
		expect(app.commands["cmd1"]!.handler).toHaveBeenCalled();
	});

	it("should fail if a required positional argument is not passed", async () => {
		const app = new Application("test-app", "Autogenerated test app");
		app.command("cmd1").description("test command").args({
			positionalArgs: [
				{
					name: "positionalArg1",
					description: "test arg"
				},
			]
		}).impl((opts, app) => {
			fail(`Handler should not be called`);
		});

		await expectAsync(runApp(app, [`cmd1`]))
			.toBeRejectedWith(applicationError("required positional arg"));
	});

	it("should fill in default values for named arguments", async () => {
		const app = new Application("test-app", "Autogenerated test app");
		app.command("cmd1").description("test command").args({
			namedArgs: {
				optional1: arg().default("defaultValue1"),
				optional2: arg().default("defaultValue2"),
				optional3: arg().default("defaultValue3"),
				optional4: arg().optional(),
				optional5: arg().optional(),
				optional6: arg().optional(),
			}
		}).impl((opts, app) => {
			types<typeof opts.namedArgs.optional1, string>().areEqual();
			types<typeof opts.namedArgs.optional2, string>().areEqual();
			types<typeof opts.namedArgs.optional3, string>().areEqual();
			types<typeof opts.namedArgs.optional4, string | undefined | null>().areEqual();
			types<typeof opts.namedArgs.optional5, string | undefined | null>().areEqual();
			types<typeof opts.namedArgs.optional6, string | undefined | null>().areEqual();
			expect(opts.namedArgs.optional1).toEqual("defaultValue1");
			expect(opts.namedArgs.optional2).toEqual("defaultValue2");
			expect(opts.namedArgs.optional3).toEqual("modified");
			expect(opts.namedArgs.optional4).toEqual("value4");
			expect(opts.namedArgs.optional5).toEqual(undefined);
			expect("optional5" in opts.namedArgs).toEqual(true);
			expect(opts.namedArgs.optional6).toEqual(null);
		});

		spyOn(app.commands["cmd1"]!, "handler").and.callThrough();
		await runApp(app, [`cmd1`, `--optional2`, `--optional3`, `modified`, `--optional4`, `value4`, `--optional6`]);
		expect(app.commands["cmd1"]!.handler).toHaveBeenCalled();
	});

	it("should fill in default values for positional arguments", async () => {
		const app = new Application("test-app", "Autogenerated test app");
		app.command("cmd1").description("test command").args({
			positionalArgs: [
				{
					name: "arg1",
					description: "test arg"
				},
				{
					name: "arg2",
					description: "test arg",
					default: "defaultValue2"
				},
			]
		}).impl((opts, app) => {
			expect(opts.positionalArgs[0]).toEqual("value1");
			expect(opts.positionalArgs[1]).toEqual("defaultValue2");
		});

		spyOn(app.commands["cmd1"]!, "handler").and.callThrough();
		await runApp(app, [`cmd1`, `value1`]);
		expect(app.commands["cmd1"]!.handler).toHaveBeenCalled();
	});

	it("should not allow required positional arguments to follow optional ones", () => {
		const app = new Application("test-app", "Autogenerated test app");
		app.command("cmd1").description("test command").args({
			positionalArgs: [
				{
					name: "arg1",
					description: "test arg",
					optional: true
				},
				{
					name: "arg2",
					description: "test arg",
					default: "defaultValue2" //this is allowed, 
				},
			]
		}).impl((opts, app) => {
			expect(opts.positionalArgs[0]).toEqual("value1");
			expect(opts.positionalArgs[1]).toEqual("defaultValue2");
		});
		expect(() => {
			app.command("cmd1").description("test command").args({
				positionalArgs: [
					{
						name: "arg1",
						description: "test arg",
						default: "defaultValue2"
					},
					{
						name: "arg2",
						description: "test arg",
					},
				]
			}).impl((opts, app) => {
				expect(opts.positionalArgs[0]).toEqual("value1");
				expect(opts.positionalArgs[1]).toEqual("defaultValue2");
			});
		}).toThrowMatching(e => (e as Error)?.message.includes("cannot follow optional ones"));
	});

	it("should run a command through aliases", async () => {
		const app = new Application("test-app", "Autogenerated test app");
		app.command("cmd1").description("test command").aliases("alias1").args({}).impl(() => {});
		spyOn(app.commands["cmd1"]!, "handler").and.callThrough();
		await runApp(app, [`alias1`]);
		expect(app.commands["cmd1"]!.handler).toHaveBeenCalled();
	});

	it("should accept aliases for named arguments", async () => {
		const app = new Application("test-app", "Autogenerated test app");
		app.command("cmd1").description("test command").args({
			namedArgs: {
				namedarg1: arg().aliases("alias1"),
				namedarg2: arg(),
			},
			aliases: {
				alias2: "namedarg2"
			}
		}).impl((opts, app) => {
			expect(opts.namedArgs.namedarg1).toEqual("namedvalue1");
			expect(opts.namedArgs.namedarg2).toEqual("namedvalue2");
		});

		spyOn(app.commands["cmd1"]!, "handler").and.callThrough();
		await runApp(app, [`cmd1`, `--alias1`, `namedvalue1`, `--alias2`, `namedvalue2`]);
		expect(app.commands["cmd1"]!.handler).toHaveBeenCalled();
	});

	it("should call process.exit when an exit code is returned", async () => {
		const app = new Application("test-app", "Autogenerated test app");
		let code = 0;
		app.command("cmd1").description("test command").args({}).impl((opts, app) => {
			return code;
		});

		spyOn(process, "exit");
		await app.run(["node", fakePathToApp, "cmd1"], {throwOnError: true, exitProcessOnHandlerReturn: true});
		// eslint-disable-next-line @typescript-eslint/unbound-method
		expect(process.exit).toHaveBeenCalledOnceWith(code);

		code = 1;
		await app.run(["node", fakePathToApp, "cmd1"], {throwOnError: true, exitProcessOnHandlerReturn: true});
		// eslint-disable-next-line @typescript-eslint/unbound-method
		expect(process.exit).toHaveBeenCalledWith(code);
	});

	it("should wait for async handlers to return", async () => {
		const app = new Application("test-app", "Autogenerated test app");
		let state = 0;
		app.command("cmd1").description("test command").args({}).impl(async (opts, app) => {
			state = 1;
			await Promise.all([delay(1), delay(2), delay(5)]);
			state = 2;
		});
		expect(state).toBe(0);
		const result = runApp(app, ["cmd1"]);
		expect(state).toBe(1);
		await result;
		expect(state).toBe(2);
	});

	it("should call process.exit when an exit code is returned asynchronously", async () => {
		const app = new Application("test-app", "Autogenerated test app");
		let code = 0;
		app.command("cmd1").description("test command").args({}).impl(async (opts, app) => {
			await delay(2);
			return code;
		});

		spyOn(process, "exit");
		await app.run(["node", fakePathToApp, "cmd1"], {throwOnError: true, exitProcessOnHandlerReturn: true});
		// eslint-disable-next-line @typescript-eslint/unbound-method
		expect(process.exit).toHaveBeenCalledOnceWith(code);

		code = 1;
		await app.run(["node", fakePathToApp, "cmd1"], {throwOnError: true, exitProcessOnHandlerReturn: true});
		// eslint-disable-next-line @typescript-eslint/unbound-method
		expect(process.exit).toHaveBeenCalledWith(code);
	});
	
});

describe("Application.parseArgs", () => {
	it("should return empty args if application run with no args", () => {
		expect(Application.parseArgs([])).toEqual({
			namedArgs: {},
			positionalArgs: [],
			firstPositionalArg: undefined,
		});
	});
	it("should parse positional args", () => {
		expect(Application.parseArgs(["sussy", "baka"])).toEqual({
			namedArgs: {},
			positionalArgs: ["sussy", "baka"],
			firstPositionalArg: "sussy",
		});
	});
	it("should parse named args", () => {
		expect(Application.parseArgs(["--sussy", "baka", "--amogus", "sus"])).toEqual({
			namedArgs: {
				sussy: "baka",
				amogus: "sus",
			},
			positionalArgs: [],
			firstPositionalArg: undefined,
		});
	});
	it("should parse named args of the form --name=value", () => {
		expect(Application.parseArgs(["--sussy", "baka", "--amogus=sus"])).toEqual({
			namedArgs: {
				sussy: "baka",
				amogus: "sus",
			},
			positionalArgs: [],
			firstPositionalArg: undefined,
		});
	});
	it("should set named args to null if a value is not specified", () => {
		expect(Application.parseArgs(["--sussy", "baka", "--amogus", "--amoma"])).toEqual({
			namedArgs: {
				sussy: "baka",
				amogus: null,
				amoma: null,
			},
			positionalArgs: [],
			firstPositionalArg: undefined,
		});
	});
	it("should parse named args and positional args", () => {
		expect(Application.parseArgs(["sus", "--sussy", "baka", "amogus", "--amoma"])).toEqual({
			namedArgs: {
				sussy: "baka",
				amoma: null,
			},
			positionalArgs: ["sus", "amogus"],
			firstPositionalArg: "sus",
		});
	});
	it("should correctly handle valuelessOptions", () => {
		expect(Application.parseArgs(["--sus", "--sussy", "baka", "--amogus", "amoma"], ["sussy"])).toEqual({
			namedArgs: {
				sus: null,
				sussy: null,
				amogus: "amoma",
			},
			positionalArgs: ["baka"],
			firstPositionalArg: undefined,
		});
	});
	it("should accept single character named arguments with one hyphen", () => {
		expect(Application.parseArgs(["-s", "baka", "-a", "sus"])).toEqual({
			namedArgs: {
				s: "baka",
				a: "sus",
			},
			positionalArgs: [],
			firstPositionalArg: undefined,
		});
	});
	it("should accept multiple one-character named arguments combined under one hyphen", () => {
		expect(Application.parseArgs(["-amo", "baka", "-gus", "sus"])).toEqual({
			namedArgs: {
				a: null,
				m: null,
				o: "baka",
				g: null,
				u: null,
				s: "sus",
			},
			positionalArgs: [],
			firstPositionalArg: undefined,
		});
	});
	it("should handle the -- arg separator", () => {
		expect(Application.parseArgs(["pos", "-s", "baka", "--", "sus", "--amogus"])).toEqual({
			namedArgs: {
				s: "baka",
			},
			positionalArgs: ["pos", "--", "sus", "--amogus"],
			firstPositionalArg: "pos",
		});
	});
	it("should accept the --name=value arg form", () => {
		expect(Application.parseArgs(["sus", "--sussy=baka", "amogus", "--amoma"])).toEqual({
			namedArgs: {
				sussy: "baka",
				amoma: null,
			},
			positionalArgs: ["sus", "amogus"],
			firstPositionalArg: "sus",
		});
	});
	it("should do all of the above", () => {
		expect(Application.parseArgs(["p1", "--n1", "v1", "p2", "p3", "-n2", "p4", "--n-3", "v-2", "--n4", "--n5", "v3", "p5"], ["sussy", "2"])).toEqual({
			namedArgs: {
				n1: "v1",
				n: null,
				"2": null,
				"n-3": "v-2",
				n4: null,
				n5: "v3",
			},
			positionalArgs: ["p1", "p2", "p3", "p4", "p5"],
			firstPositionalArg: "p1",
		});
	});
});



